diff --git a/lib/asio_client_session_impl.cc b/lib/asio_client_session_impl.cc
index b96824d..7084abb 100644
--- a/lib/asio_client_session_impl.cc
+++ b/lib/asio_client_session_impl.cc
@@ -72,15 +72,15 @@ void session_impl::start_resolve(const std::string &host,
 
   auto self = shared_from_this();
 
-  resolver_.async_resolve({host, service},
+  resolver_.async_resolve(host, service,
                           [self](const boost::system::error_code &ec,
-                                 tcp::resolver::iterator endpoint_it) {
+                                 tcp::resolver::results_type endpoints) {
                             if (ec) {
                               self->not_connected(ec);
                               return;
                             }
 
-                            self->start_connect(endpoint_it);
+                            self->start_connect(endpoints.begin());
                           });
 
   deadline_.async_wait(std::bind(&session_impl::handle_deadline, self));
@@ -124,7 +124,7 @@ void session_impl::handle_ping(const boost::system::error_code &ec) {
   start_ping();
 }
 
-void session_impl::connected(tcp::resolver::iterator endpoint_it) {
+void session_impl::connected(tcp::resolver::results_type::iterator endpoint_it) {
   if (!setup_session()) {
     return;
   }
diff --git a/lib/asio_client_session_impl.h b/lib/asio_client_session_impl.h
index 694ac20..2462d81 100644
--- a/lib/asio_client_session_impl.h
+++ b/lib/asio_client_session_impl.h
@@ -49,7 +49,7 @@ public:
 
   void start_resolve(const std::string &host, const std::string &service);
 
-  void connected(tcp::resolver::iterator endpoint_it);
+  void connected(tcp::resolver::results_type::iterator endpoint_it);
   void not_connected(const boost::system::error_code &ec);
 
   void on_connect(connect_cb cb);
@@ -72,7 +72,7 @@ public:
                         const std::string &method, const std::string &uri,
                         generator_cb cb, header_map h, priority_spec spec);
 
-  virtual void start_connect(tcp::resolver::iterator endpoint_it) = 0;
+  virtual void start_connect(tcp::resolver::results_type::iterator endpoint_it) = 0;
   virtual tcp::socket &socket() = 0;
   virtual void read_socket(
       std::function<void(const boost::system::error_code &ec, std::size_t n)>
diff --git a/lib/asio_client_session_tcp_impl.cc b/lib/asio_client_session_tcp_impl.cc
index 8fdf211..b574111 100644
--- a/lib/asio_client_session_tcp_impl.cc
+++ b/lib/asio_client_session_tcp_impl.cc
@@ -48,7 +48,7 @@ session_tcp_impl::session_tcp_impl(
 
 session_tcp_impl::~session_tcp_impl() {}
 
-void session_tcp_impl::start_connect(tcp::resolver::iterator endpoint_it) {
+void session_tcp_impl::start_connect(tcp::resolver::results_type::iterator endpoint_it) {
   auto self = shared_from_this();
   socket_.async_connect(
       *endpoint_it, [self, endpoint_it](const boost::system::error_code &ec) {
diff --git a/lib/asio_client_session_tcp_impl.h b/lib/asio_client_session_tcp_impl.h
index 0b6ae93..a4198a2 100644
--- a/lib/asio_client_session_tcp_impl.h
+++ b/lib/asio_client_session_tcp_impl.h
@@ -46,7 +46,7 @@ public:
                    const boost::posix_time::time_duration &connect_timeout);
   virtual ~session_tcp_impl();
 
-  virtual void start_connect(tcp::resolver::iterator endpoint_it);
+  virtual void start_connect(tcp::resolver::results_type::iterator endpoint_it);
   virtual tcp::socket &socket();
   virtual void read_socket(
       std::function<void(const boost::system::error_code &ec, std::size_t n)>
diff --git a/lib/asio_client_session_tls_impl.cc b/lib/asio_client_session_tls_impl.cc
index 377886c..1323fee 100644
--- a/lib/asio_client_session_tls_impl.cc
+++ b/lib/asio_client_session_tls_impl.cc
@@ -37,7 +37,7 @@ session_tls_impl::session_tls_impl(
   // this callback setting is no effect is
   // ssl::context::set_verify_mode(boost::asio::ssl::verify_peer) is
   // not used, which is what we want.
-  socket_.set_verify_callback(boost::asio::ssl::rfc2818_verification(host));
+  socket_.set_verify_callback(boost::asio::ssl::host_name_verification(host));
   auto ssl = socket_.native_handle();
   if (!util::numeric_host(host.c_str())) {
     SSL_set_tlsext_host_name(ssl, host.c_str());
@@ -46,12 +46,12 @@ session_tls_impl::session_tls_impl(
 
 session_tls_impl::~session_tls_impl() {}
 
-void session_tls_impl::start_connect(tcp::resolver::iterator endpoint_it) {
+void session_tls_impl::start_connect(tcp::resolver::results_type::iterator endpoint_it) {
   auto self = std::static_pointer_cast<session_tls_impl>(shared_from_this());
   boost::asio::async_connect(
       socket(), endpoint_it,
       [self](const boost::system::error_code &ec,
-             tcp::resolver::iterator endpoint_it) {
+             tcp::resolver::results_type::iterator it) {
         if (self->stopped()) {
           return;
         }
@@ -60,10 +60,9 @@ void session_tls_impl::start_connect(tcp::resolver::iterator endpoint_it) {
           self->not_connected(ec);
           return;
         }
-
         self->socket_.async_handshake(
             boost::asio::ssl::stream_base::client,
-            [self, endpoint_it](const boost::system::error_code &ec) {
+            [self, it](const boost::system::error_code &ec) {
               if (self->stopped()) {
                 return;
               }
@@ -79,7 +78,7 @@ void session_tls_impl::start_connect(tcp::resolver::iterator endpoint_it) {
                 return;
               }
 
-              self->connected(endpoint_it);
+              self->connected(it);
             });
       });
 }
diff --git a/lib/asio_client_session_tls_impl.h b/lib/asio_client_session_tls_impl.h
index 645c60f..00c171f 100644
--- a/lib/asio_client_session_tls_impl.h
+++ b/lib/asio_client_session_tls_impl.h
@@ -45,7 +45,7 @@ public:
                    const boost::posix_time::time_duration &connect_timeout);
   virtual ~session_tls_impl();
 
-  virtual void start_connect(tcp::resolver::iterator endpoint_it);
+  virtual void start_connect(tcp::resolver::results_type::iterator endpoint_it);
   virtual tcp::socket &socket();
   virtual void read_socket(
       std::function<void(const boost::system::error_code &ec, std::size_t n)>
diff --git a/lib/asio_io_service_pool.cc b/lib/asio_io_service_pool.cc
index 0148366..022c6a3 100644
--- a/lib/asio_io_service_pool.cc
+++ b/lib/asio_io_service_pool.cc
@@ -48,7 +48,7 @@ io_service_pool::io_service_pool(std::size_t pool_size) : next_io_service_(0) {
   // exit until they are explicitly stopped.
   for (std::size_t i = 0; i < pool_size; ++i) {
     auto io_service = std::make_shared<boost::asio::io_service>();
-    auto work = std::make_shared<boost::asio::io_service::work>(*io_service);
+    auto work = std::make_shared<boost::asio::io_context_work>(io_service->get_executor());
     io_services_.push_back(io_service);
     work_.push_back(work);
   }
diff --git a/lib/asio_io_service_pool.h b/lib/asio_io_service_pool.h
index 9c11533..901043b 100644
--- a/lib/asio_io_service_pool.h
+++ b/lib/asio_io_service_pool.h
@@ -82,7 +82,7 @@ private:
   std::vector<std::shared_ptr<boost::asio::io_service>> io_services_;
 
   /// The work that keeps the io_services running.
-  std::vector<std::shared_ptr<boost::asio::io_service::work>> work_;
+  std::vector<std::shared_ptr<boost::asio::io_context_work>> work_;
 
   /// The next io_service to use for a connection.
   std::size_t next_io_service_;
diff --git a/lib/asio_server.cc b/lib/asio_server.cc
index 74c9227..5d74680 100644
--- a/lib/asio_server.cc
+++ b/lib/asio_server.cc
@@ -82,14 +82,13 @@ boost::system::error_code server::bind_and_listen(boost::system::error_code &ec,
   // Open the acceptor with the option to reuse the address (i.e.
   // SO_REUSEADDR).
   tcp::resolver resolver(io_service_pool_.get_io_service());
-  tcp::resolver::query query(address, port);
-  auto it = resolver.resolve(query, ec);
+  auto results = resolver.resolve(address, port, ec);
   if (ec) {
     return ec;
   }
 
-  for (; it != tcp::resolver::iterator(); ++it) {
-    tcp::endpoint endpoint = *it;
+  for (auto it : results) {
+    tcp::endpoint endpoint = it.endpoint();
     auto acceptor = tcp::acceptor(io_service_pool_.get_io_service());
 
     if (acceptor.open(endpoint.protocol(), ec)) {
@@ -103,7 +102,7 @@ boost::system::error_code server::bind_and_listen(boost::system::error_code &ec,
     }
 
     if (acceptor.listen(
-            backlog == -1 ? boost::asio::socket_base::max_connections : backlog,
+            backlog == -1 ? boost::asio::socket_base::max_listen_connections : backlog,
             ec)) {
       continue;
     }
diff --git a/lib/asio_server_http2_handler.cc b/lib/asio_server_http2_handler.cc
index c1fc195..2c2ab2a 100644
--- a/lib/asio_server_http2_handler.cc
+++ b/lib/asio_server_http2_handler.cc
@@ -415,7 +415,7 @@ void http2_handler::signal_write() {
   if (!inside_callback_ && !write_signaled_) {
     write_signaled_ = true;
     auto self = shared_from_this();
-    io_service_.post([self]() { self->initiate_write(); });
+    boost::asio::post(io_service_, [self]() { self->initiate_write(); });
   }
 }
 
diff --git a/lib/includes/nghttp2/asio_http2.h b/lib/includes/nghttp2/asio_http2.h
index 57e55e1..b5accac 100644
--- a/lib/includes/nghttp2/asio_http2.h
+++ b/lib/includes/nghttp2/asio_http2.h
@@ -38,6 +38,59 @@
 
 #include <nghttp2/nghttp2.h>
 
+namespace boost {
+  namespace asio {
+    #if BOOST_VERSION >= 108700
+      using io_service = boost::asio::io_context;
+      using const_buffers_1 = boost::asio::const_buffer;
+      using mutable_buffers_1 = boost::asio::mutable_buffer;
+      using io_context_work = boost::asio::executor_work_guard<boost::asio::io_context::executor_type>;
+      /// Cast a non-modifiable buffer to a specified pointer to POD type.
+      template <typename PointerToPodType>
+      inline PointerToPodType buffer_cast(const mutable_buffer& b) noexcept
+      {
+        return static_cast<PointerToPodType>(b.data());
+      }
+
+      /// Cast a non-modifiable buffer to a specified pointer to POD type.
+      template <typename PointerToPodType>
+      inline PointerToPodType buffer_cast(const const_buffer& b) noexcept
+      {
+        return static_cast<PointerToPodType>(b.data());
+      }
+
+      template <typename Protocol, typename Executor, typename Iterator,
+          BOOST_ASIO_COMPLETION_TOKEN_FOR(void (boost::system::error_code,
+            Iterator)) IteratorConnectToken = default_completion_token_t<Executor>>
+      inline auto async_connect(basic_socket<Protocol, Executor>& s, Iterator begin,
+          IteratorConnectToken&& token = default_completion_token_t<Executor>(),
+          constraint_t<
+            !is_endpoint_sequence<Iterator>::value
+          > = 0,
+          constraint_t<
+            !is_same<Iterator, decay_t<IteratorConnectToken>>::value
+          > = 0,
+          constraint_t<
+            !is_connect_condition<IteratorConnectToken, Iterator>::value
+          > = 0)
+        -> decltype(
+          async_initiate<IteratorConnectToken,
+            void (boost::system::error_code, Iterator)>(
+              declval<detail::initiate_async_iterator_connect<Protocol, Executor>>(),
+              token, begin, Iterator(),
+              declval<detail::default_connect_condition>()))
+      {
+        return async_initiate<IteratorConnectToken,
+          void (boost::system::error_code, Iterator)>(
+            detail::initiate_async_iterator_connect<Protocol, Executor>(s),
+            token, begin, Iterator(), detail::default_connect_condition());
+      }
+    #else
+      using io_context_work = boost::asio::io_service::work;
+    #endif
+  }
+}
+
 namespace nghttp2 {
 
 namespace asio_http2 {
diff --git a/lib/includes/nghttp2/asio_http2_client.h b/lib/includes/nghttp2/asio_http2_client.h
index 7257914..49675b8 100644
--- a/lib/includes/nghttp2/asio_http2_client.h
+++ b/lib/includes/nghttp2/asio_http2_client.h
@@ -67,7 +67,7 @@ class request;
 using response_cb = std::function<void(const response &)>;
 using request_cb = std::function<void(const request &)>;
 using connect_cb =
-    std::function<void(boost::asio::ip::tcp::resolver::iterator)>;
+    std::function<void(boost::asio::ip::tcp::resolver::results_type::iterator)>;
 
 class request_impl;
 
