diff --git a/src/3rdparty/chromium/build/config/compiler/BUILD.gn b/src/3rdparty/chromium/build/config/compiler/BUILD.gn
index b511a58c5..a27a45d2e 100644
--- a/src/3rdparty/chromium/build/config/compiler/BUILD.gn
+++ b/src/3rdparty/chromium/build/config/compiler/BUILD.gn
@@ -64,7 +64,7 @@ declare_args() {
 
   # Enable fatal linker warnings. Building Chromium with certain versions
   # of binutils can cause linker warning.
-  fatal_linker_warnings = true
+  fatal_linker_warnings = false
 
   # Build with C++ RTTI enabled. Chromium builds without RTTI by default,
   # but some sanitizers are known to require it, like CFI diagnostics
@@ -1502,6 +1502,7 @@ config("default_warnings") {
       # Disable a number of GCC warnings caused by a mix
       # of Chromium and GCC bugs.
       cflags += [ "-Wno-dangling-else" ]
+      cflags += [ "-fpermissive" ]
       cflags_cc += [ "-Wno-attributes" ]
       cflags_cc += [ "-Wno-class-memaccess" ]
       cflags_cc += [ "-Wno-subobject-linkage" ]
diff --git a/src/3rdparty/chromium/build/config/pch.gni b/src/3rdparty/chromium/build/config/pch.gni
index 93bd2fedc..a55fbaecd 100644
--- a/src/3rdparty/chromium/build/config/pch.gni
+++ b/src/3rdparty/chromium/build/config/pch.gni
@@ -8,5 +8,5 @@ declare_args() {
   # Precompiled header file support is by default available,
   # but for distributed build system uses (like goma) or when
   # doing official builds.
-  enable_precompiled_headers = !is_official_build && !use_goma
+  enable_precompiled_headers = false
 }
diff --git a/src/3rdparty/chromium/gpu/command_buffer/service/program_manager.cc b/src/3rdparty/chromium/gpu/command_buffer/service/program_manager.cc
index 021530c7e..5db4135ae 100644
--- a/src/3rdparty/chromium/gpu/command_buffer/service/program_manager.cc
+++ b/src/3rdparty/chromium/gpu/command_buffer/service/program_manager.cc
@@ -620,7 +620,7 @@ std::string Program::ProcessLogInfo(const std::string& log) {
       output += hashed_name;
   }
 
-  return output + input.as_string();
+  return output + static_cast<std::string>(input);
 }
 
 void Program::UpdateLogInfo() {
diff --git a/src/3rdparty/chromium/third_party/blink/renderer/core/BUILD.gn b/src/3rdparty/chromium/third_party/blink/renderer/core/BUILD.gn
index 5dc17a425..0047a2796 100644
--- a/src/3rdparty/chromium/third_party/blink/renderer/core/BUILD.gn
+++ b/src/3rdparty/chromium/third_party/blink/renderer/core/BUILD.gn
@@ -37,27 +37,6 @@ config("core_include_dirs") {
 import("//build/config/pch.gni")
 
 config("blink_core_pch") {
-  # Add precompiled header (pch) support when enabled, possible and
-  # making sense.
-  if (enable_precompiled_headers) {
-    if (is_win) {
-      # This is a string rather than a file GN knows about. It has to match
-      # exactly what's in the /FI flag below, and what might appear in the
-      # source code in quotes for an #include directive.
-      precompiled_header = rebase_path("precompile_core.h", root_build_dir)
-
-      # This is a file that GN will compile with the above header. It will be
-      # implicitly added to the sources (potentially multiple times, with one
-      # variant for each language used in the target).
-      precompiled_source =
-          "//third_party/blink/renderer/core/win/precompile_core.cc"
-
-      # Force include the header.
-      cflags = [ "/FI$precompiled_header" ]
-    } else if (is_mac) {
-      precompiled_source = "//third_party/blink/renderer/core/precompile_core.h"
-    }
-  }
 }
 
 core_config_add += [
diff --git a/src/3rdparty/chromium/third_party/blink/renderer/platform/BUILD.gn b/src/3rdparty/chromium/third_party/blink/renderer/platform/BUILD.gn
index 2e0d575a9..d1acfa8b5 100644
--- a/src/3rdparty/chromium/third_party/blink/renderer/platform/BUILD.gn
+++ b/src/3rdparty/chromium/third_party/blink/renderer/platform/BUILD.gn
@@ -218,28 +218,6 @@ config("blink_platform_implementation") {
 }
 
 config("blink_platform_pch") {
-  visibility = []
-  visibility = [ "./*" ]
-  if (enable_precompiled_headers) {
-    if (is_win) {
-      # This is a string rather than a file GN knows about. It has to match
-      # exactly what's in the /FI flag below, and what might appear in the
-      # source code in quotes for an #include directive.
-      precompiled_header = rebase_path("precompile_platform.h", root_build_dir)
-
-      # This is a file that GN will compile with the above header. It will be
-      # implicitly added to the sources (potentially multiple times, with one
-      # variant for each language used in the target).
-      precompiled_source =
-          "//third_party/blink/renderer/platform/win/precompile_platform.cc"
-
-      # Force include the header.
-      cflags = [ "/FI$precompiled_header" ]
-    } else if (is_mac) {
-      precompiled_source =
-          "//third_party/blink/renderer/platform/precompile_platform.h"
-    }
-  }
 }
 
 source_set("platform_export") {
diff --git a/src/3rdparty/chromium/third_party/ffmpeg/libavcodec/x86/mathops.h b/src/3rdparty/chromium/third_party/ffmpeg/libavcodec/x86/mathops.h
index 6298f5ed1..ca7e2dffc 100644
--- a/src/3rdparty/chromium/third_party/ffmpeg/libavcodec/x86/mathops.h
+++ b/src/3rdparty/chromium/third_party/ffmpeg/libavcodec/x86/mathops.h
@@ -35,12 +35,20 @@
 static av_always_inline av_const int MULL(int a, int b, unsigned shift)
 {
     int rt, dummy;
+    if (__builtin_constant_p(shift))
     __asm__ (
         "imull %3               \n\t"
         "shrdl %4, %%edx, %%eax \n\t"
         :"=a"(rt), "=d"(dummy)
-        :"a"(a), "rm"(b), "ci"((uint8_t)shift)
+        :"a"(a), "rm"(b), "i"(shift & 0x1F)
     );
+    else
+        __asm__ (
+            "imull %3               \n\t"
+            "shrdl %4, %%edx, %%eax \n\t"
+            :"=a"(rt), "=d"(dummy)
+            :"a"(a), "rm"(b), "c"((uint8_t)shift)
+        );
     return rt;
 }
 
@@ -113,19 +121,31 @@ __asm__ volatile(\
 // avoid +32 for shift optimization (gcc should do that ...)
 #define NEG_SSR32 NEG_SSR32
 static inline  int32_t NEG_SSR32( int32_t a, int8_t s){
+    if (__builtin_constant_p(s))
     __asm__ ("sarl %1, %0\n\t"
          : "+r" (a)
-         : "ic" ((uint8_t)(-s))
+         : "i" (-s & 0x1F)
     );
+    else
+        __asm__ ("sarl %1, %0\n\t"
+               : "+r" (a)
+               : "c" ((uint8_t)(-s))
+        );
     return a;
 }
 
 #define NEG_USR32 NEG_USR32
 static inline uint32_t NEG_USR32(uint32_t a, int8_t s){
+    if (__builtin_constant_p(s))
     __asm__ ("shrl %1, %0\n\t"
          : "+r" (a)
-         : "ic" ((uint8_t)(-s))
+         : "i" (-s & 0x1F)
     );
+    else
+        __asm__ ("shrl %1, %0\n\t"
+               : "+r" (a)
+               : "c" ((uint8_t)(-s))
+        );
     return a;
 }
 
