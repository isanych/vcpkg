diff --git a/src/Common/QuickFASTPch.h b/src/Common/QuickFASTPch.h
index 3574df8..c4ef4e1 100644
--- a/src/Common/QuickFASTPch.h
+++ b/src/Common/QuickFASTPch.h
@@ -32,7 +32,7 @@
 #include <string.h>
 
 // If building for .NET, must link boost threads dynamically
-#define BOOST_THREAD_USE_DLL
+// #define BOOST_THREAD_USE_DLL
 // This reports at compile time which boost libraries will be used
 // #define BOOST_LIB_DIAGNOSTIC
 
diff --git a/src/Communication/AsioService.h b/src/Communication/AsioService.h
index 4f61915..4e597cf 100644
--- a/src/Communication/AsioService.h
+++ b/src/Communication/AsioService.h
@@ -15,6 +15,32 @@
 // In gcc including asio.hpp in precompiled headers causes problems
 #include <boost/asio.hpp>
 
+namespace boost {
+  namespace asio {
+    #if BOOST_VERSION >= 108700
+      using io_service = boost::asio::io_context;
+      using const_buffers_1 = boost::asio::const_buffer;
+      using mutable_buffers_1 = boost::asio::mutable_buffer;
+      using io_context_work = boost::asio::executor_work_guard<boost::asio::io_context::executor_type>;
+      /// Cast a non-modifiable buffer to a specified pointer to POD type.
+      template <typename PointerToPodType>
+      inline PointerToPodType buffer_cast(const mutable_buffer& b) noexcept
+      {
+        return static_cast<PointerToPodType>(b.data());
+      }
+
+      /// Cast a non-modifiable buffer to a specified pointer to POD type.
+      template <typename PointerToPodType>
+      inline PointerToPodType buffer_cast(const const_buffer& b) noexcept
+      {
+        return static_cast<PointerToPodType>(b.data());
+      }
+    #else
+      using io_context_work = boost::asio::io_service::work;
+    #endif
+  }
+}
+
 namespace QuickFAST
 {
   namespace Communication
@@ -87,7 +113,7 @@ namespace QuickFAST
       /// should be called after joinThreads before calling run*, poll*, etc. again.
       void resetService()
       {
-        ioService_.reset();
+        ioService_.restart();
         stopping_ = false;
       }
 
@@ -100,12 +126,14 @@ namespace QuickFAST
         return ioService_;
       }
 
+      boost::asio::io_service::executor_type get_executor() BOOST_ASIO_NOEXCEPT { return ioService_.get_executor();}
+
       ///@brief Post a completion handler for later processing (usually in a different thread)
       /// @param handler is the handler to be posted
       template<typename CompletionHandler>
       void post(CompletionHandler handler)
       {
-        ioService_.post(handler);
+        boost::asio::post(ioService_, handler);
       }
 
       /// @brief Attempt to determine how many threads are available to ASIO
diff --git a/src/Communication/AsioService_fwd.h b/src/Communication/AsioService_fwd.h
index dc2f235..6ad5e68 100644
--- a/src/Communication/AsioService_fwd.h
+++ b/src/Communication/AsioService_fwd.h
@@ -17,7 +17,8 @@ namespace boost
 {
   namespace asio
   {
-    class io_service;
+    class io_context;
+    typedef io_context io_service;
   }
 }
 
diff --git a/src/Communication/AsynchReceiver.h b/src/Communication/AsynchReceiver.h
index 00c1d9c..cc4a32f 100644
--- a/src/Communication/AsynchReceiver.h
+++ b/src/Communication/AsynchReceiver.h
@@ -132,7 +132,7 @@ namespace QuickFAST
       template<typename CompletionHandler>
       void post(CompletionHandler handler)
       {
-        ioService_.post(handler);
+        boost::asio::post(ioService_, handler);
       }
 
     protected:
diff --git a/src/Communication/AsynchSender.cpp b/src/Communication/AsynchSender.cpp
index 0261302..f843437 100644
--- a/src/Communication/AsynchSender.cpp
+++ b/src/Communication/AsynchSender.cpp
@@ -15,7 +15,7 @@ AsynchSender::AsynchSender(
     : Sender(recycler)
     , name_(name)
     , ioService_()
-    , keepAlive_(new boost::asio::io_service::work(ioService_))
+    , keepAlive_(new boost::asio::io_context_work(ioService_.get_executor()))
 {
   //std::cout << "Asynch Sender {" << (void *)this << "} keeping ioService " << (void*) &ioService_ << " alive." << std::endl;
 }
@@ -27,7 +27,7 @@ AsynchSender::AsynchSender(
     : Sender(recycler)
     , name_(name)
     , ioService_(ioService)
-    , keepAlive_(new boost::asio::io_service::work(ioService_))
+    , keepAlive_(new boost::asio::io_context_work(ioService_.get_executor()))
 {
 //  std::cout << "Asynch Sender {" << (void *)this << "} keeping shared ioService " << (void*) &ioService_ << " alive." << std::endl;
 }
diff --git a/src/Communication/AsynchSender.h b/src/Communication/AsynchSender.h
index 5eb02c2..53ffa3b 100644
--- a/src/Communication/AsynchSender.h
+++ b/src/Communication/AsynchSender.h
@@ -111,7 +111,7 @@ namespace QuickFAST
       /// needed for output-type service which may have nothing to write at the moment, unlike
       /// input-type services which should always have an outstanding read or an active handler
       /// callback.
-      boost::scoped_ptr<boost::asio::io_service::work> keepAlive_;
+      boost::scoped_ptr<boost::asio::io_context_work> keepAlive_;
     };
   }
 }
diff --git a/src/Communication/MulticastReceiver.h b/src/Communication/MulticastReceiver.h
index cb9a999..a029171 100644
--- a/src/Communication/MulticastReceiver.h
+++ b/src/Communication/MulticastReceiver.h
@@ -36,10 +36,10 @@ namespace QuickFAST
           )
         : parent_(parent)
         , name_(name)
-        , listenInterface_(boost::asio::ip::address::from_string(listenInterfaceIP))
+        , listenInterface_(boost::asio::ip::make_address(listenInterfaceIP))
         , portNumber_(portNumber)
-        , multicastGroup_(boost::asio::ip::address::from_string(multicastGroupIP))
-        , bindAddress_(boost::asio::ip::address::from_string(bindIP))
+        , multicastGroup_(boost::asio::ip::make_address(multicastGroupIP))
+        , bindAddress_(boost::asio::ip::make_address(bindIP))
         , endpoint_(listenInterface_, portNumber)
         , socket_(ioService)
         , joined_(false)
diff --git a/src/Communication/MulticastSender.h b/src/Communication/MulticastSender.h
index f0c7be1..89a0d0e 100644
--- a/src/Communication/MulticastSender.h
+++ b/src/Communication/MulticastSender.h
@@ -62,7 +62,7 @@ namespace QuickFAST
       ///@brief Prepare the sender to be used
       bool initializeSender()
       {
-        multicastAddress_ = boost::asio::ip::address::from_string(sendAddress_);
+        multicastAddress_ = boost::asio::ip::make_address(sendAddress_);
         endpoint_ = boost::asio::ip::udp::endpoint(multicastAddress_, portNumber_);
         socket_.open(endpoint_.protocol());
         return true;
diff --git a/src/Communication/TCPReceiver.h b/src/Communication/TCPReceiver.h
index 6ddb436..6c41860 100644
--- a/src/Communication/TCPReceiver.h
+++ b/src/Communication/TCPReceiver.h
@@ -60,12 +60,12 @@ namespace QuickFAST
         bool ok = true;
         // generate a collection of possible endpoints for this host:port
         boost::asio::ip::tcp::resolver resolver(ioService_);
-        boost::asio::ip::tcp::resolver::query query( hostName_, port_);
-        boost::asio::ip::tcp::resolver::iterator iterator = resolver.resolve(query);
+        auto results = resolver.resolve(hostName_, port_);
+        auto iterator = results.begin();
+        auto endIterator = results.end();
 
         // then iterate thru the collection until we find one that works.
         boost::system::error_code error;
-        boost::asio::ip::tcp::resolver::iterator endIterator;
         bool connected = false;
         while(!connected && iterator != endIterator)
         {
diff --git a/src/Examples/PCapToMulticast/PCapToMulticast.cpp b/src/Examples/PCapToMulticast/PCapToMulticast.cpp
index c08d11f..114e2a1 100644
--- a/src/Examples/PCapToMulticast/PCapToMulticast.cpp
+++ b/src/Examples/PCapToMulticast/PCapToMulticast.cpp
@@ -166,7 +166,7 @@ PCapToMulticast::applyArgs()
     }
     ok = ok && pcapReader_.open(dataFileName_.c_str());// for debugging dump to->, &std::cout);
 
-    multicastAddress_ = boost::asio::ip::address::from_string(sendAddress_);
+    multicastAddress_ = boost::asio::ip::make_address(sendAddress_);
     endpoint_ = boost::asio::ip::udp::endpoint(multicastAddress_, portNumber_);
     socket_.open(endpoint_.protocol());
     std::cout << "Opening multicast group: " << endpoint_.address().to_string() << ':' << endpoint_.port() << std::endl;
