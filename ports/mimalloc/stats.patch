diff --git a/include/mimalloc.h b/include/mimalloc.h
index f77c2ea..16cfba8 100644
--- a/include/mimalloc.h
+++ b/include/mimalloc.h
@@ -103,6 +103,20 @@ terms of the MIT license. A copy of the license can be found in the file
 extern "C" {
 #endif
 
+// ------------------------------------------------------
+// PRQA interface
+// ------------------------------------------------------
+
+typedef struct mi_prqa_stat_s {
+    size_t tid;
+    int64_t current;
+    int64_t peak;
+} mi_prqa_stat_t;
+
+mi_decl_nodiscard mi_decl_export mi_prqa_stat_t mi_get_prqa_malloc_stat() mi_attr_noexcept;
+mi_decl_export void mi_reset_prqa_malloc_stat() mi_attr_noexcept;
+mi_decl_export void mi_track_prqa_malloc_stat(bool enable) mi_attr_noexcept;
+
 // ------------------------------------------------------
 // Standard malloc interface
 // ------------------------------------------------------
@@ -154,6 +168,7 @@ mi_decl_export void mi_stats_reset(void)      mi_attr_noexcept;
 mi_decl_export void mi_stats_merge(void)      mi_attr_noexcept;
 mi_decl_export void mi_stats_print(void* out) mi_attr_noexcept;  // backward compatibility: `out` is ignored and should be NULL
 mi_decl_export void mi_stats_print_out(mi_output_fun* out, void* arg) mi_attr_noexcept;
+mi_decl_export void mi_pretty_print_bytes(int64_t n, char* out, int len) mi_attr_noexcept;
 
 mi_decl_export void mi_process_init(void)     mi_attr_noexcept;
 mi_decl_export void mi_thread_init(void)      mi_attr_noexcept;
diff --git a/include/mimalloc/internal.h b/include/mimalloc/internal.h
index 00d2626..cdc8f8d 100644
--- a/include/mimalloc/internal.h
+++ b/include/mimalloc/internal.h
@@ -182,6 +182,15 @@ mi_msecs_t  _mi_clock_now(void);
 mi_msecs_t  _mi_clock_end(mi_msecs_t start);
 mi_msecs_t  _mi_clock_start(void);
 
+static inline int _mi_prqa_stat_base_value(int value) {
+  if (value >= 10) {
+    return value - 10;
+  }
+  else {
+    return value;
+  }
+}
+
 // "alloc.c"
 void*       _mi_page_malloc(mi_heap_t* heap, mi_page_t* page, size_t size, bool zero) mi_attr_noexcept;  // called from `_mi_malloc_generic`
 void*       _mi_heap_malloc_zero(mi_heap_t* heap, size_t size, bool zero) mi_attr_noexcept;
@@ -975,5 +984,10 @@ static inline void _mi_memzero_aligned(void* dst, size_t n) {
 }
 #endif
 
+// -------------------------------------------------------------------------------
+// Statistics
+// -------------------------------------------------------------------------------
+
+extern mi_decl_thread int tls_prqa_stat;
 
 #endif
diff --git a/include/mimalloc/types.h b/include/mimalloc/types.h
index 2005238..8710f6d 100644
--- a/include/mimalloc/types.h
+++ b/include/mimalloc/types.h
@@ -589,6 +589,7 @@ typedef struct mi_stats_s {
   mi_stat_count_t huge;
   mi_stat_count_t large;
   mi_stat_count_t malloc;
+  mi_stat_count_t prqa_malloc;
   mi_stat_count_t segments_cache;
   mi_stat_counter_t pages_extended;
   mi_stat_counter_t mmap_calls;
@@ -624,6 +625,14 @@ void _mi_stat_counter_increase(mi_stat_counter_t* stat, size_t amount);
 #define mi_heap_stat_increase(heap,stat,amount)  mi_stat_increase( (heap)->tld->stats.stat, amount)
 #define mi_heap_stat_decrease(heap,stat,amount)  mi_stat_decrease( (heap)->tld->stats.stat, amount)
 
+// Applicable to release and debug builds
+
+#define mi_stat_do_increase(stat,amount)         _mi_stat_increase( &(stat), amount)
+#define mi_stat_do_decrease(stat,amount)         _mi_stat_decrease( &(stat), amount)
+
+#define mi_heap_stat_do_increase(heap,stat,amount)  mi_stat_do_increase( (heap)->tld->stats.stat, amount)
+#define mi_heap_stat_do_decrease(heap,stat,amount)  mi_stat_do_decrease( (heap)->tld->stats.stat, amount)
+
 // ------------------------------------------------------
 // Thread Local data
 // ------------------------------------------------------
diff --git a/src/alloc-aligned.c b/src/alloc-aligned.c
index 1cd809f..5e26836 100644
--- a/src/alloc-aligned.c
+++ b/src/alloc-aligned.c
@@ -115,9 +115,17 @@ static void* mi_heap_malloc_zero_aligned_at(mi_heap_t* const heap, const size_t
     const bool is_aligned = (((uintptr_t)page->free+offset) & align_mask)==0;
     if mi_likely(page->free != NULL && is_aligned)
     {
-      #if MI_STAT>1
-      mi_heap_stat_increase(heap, malloc, size);
-      #endif
+      const int prqa_stat_value = tls_prqa_stat;
+      if (prqa_stat_value > 1) {
+        const int base_value = _mi_prqa_stat_base_value(prqa_stat_value);
+        if (base_value > 1) {
+          mi_heap_stat_increase(heap, malloc, size);
+        }
+
+        if (prqa_stat_value >= 10) {
+          mi_heap_stat_do_increase(heap, prqa_malloc, size);
+        }
+      }
       void* p = _mi_page_malloc(heap, page, padsize, zero); // TODO: inline _mi_page_malloc
       mi_assert_internal(p != NULL);
       mi_assert_internal(((uintptr_t)p + offset) % alignment == 0);
diff --git a/src/alloc.c b/src/alloc.c
index ffc1747..7f19fe9 100644
--- a/src/alloc.c
+++ b/src/alloc.c
@@ -115,12 +115,18 @@ static inline mi_decl_restrict void* mi_heap_malloc_small_zero(mi_heap_t* heap,
   mi_page_t* page = _mi_heap_get_free_small_page(heap, size + MI_PADDING_SIZE);
   void* const p = _mi_page_malloc(heap, page, size + MI_PADDING_SIZE, zero);  
   mi_track_malloc(p,size,zero);
-  #if MI_STAT>1
-  if (p != NULL) {
+  const int prqa_stat_value = tls_prqa_stat;
+  if (p != NULL && prqa_stat_value > 1) {
     if (!mi_heap_is_initialized(heap)) { heap = mi_prim_get_default_heap(); }
-    mi_heap_stat_increase(heap, malloc, mi_usable_size(p));
+    const int base_value = _mi_prqa_stat_base_value(prqa_stat_value);
+    if (base_value > 1) {
+      mi_heap_stat_increase(heap, malloc, mi_usable_size(p));
+    }
+
+    if (prqa_stat_value >= 10) {
+      mi_heap_stat_do_increase(heap, prqa_malloc, mi_usable_size(p));
+    }
   }
-  #endif
   #if MI_DEBUG>3
   if (p != NULL && zero) {
     mi_assert_expensive(mi_mem_is_zero(p, size));
@@ -149,12 +155,18 @@ extern inline void* _mi_heap_malloc_zero_ex(mi_heap_t* heap, size_t size, bool z
     mi_assert(heap->thread_id == 0 || heap->thread_id == _mi_thread_id());   // heaps are thread local
     void* const p = _mi_malloc_generic(heap, size + MI_PADDING_SIZE, zero, huge_alignment);  // note: size can overflow but it is detected in malloc_generic
     mi_track_malloc(p,size,zero);
-    #if MI_STAT>1
-    if (p != NULL) {
+    const int prqa_stat_value = tls_prqa_stat;
+    if (p != NULL && prqa_stat_value > 1) {
       if (!mi_heap_is_initialized(heap)) { heap = mi_prim_get_default_heap(); }
-      mi_heap_stat_increase(heap, malloc, mi_usable_size(p));
+      const int base_value = _mi_prqa_stat_base_value(prqa_stat_value);
+      if (base_value > 1) {
+        mi_heap_stat_increase(heap, malloc, mi_usable_size(p));
+      }
+
+      if (prqa_stat_value >= 10) {
+        mi_heap_stat_do_increase(heap, prqa_malloc, mi_usable_size(p));
+      }
     }
-    #endif
     #if MI_DEBUG>3
     if (p != NULL && zero) {
       mi_assert_expensive(mi_mem_is_zero(p, size));
@@ -344,35 +356,40 @@ static void mi_check_padding(const mi_page_t* page, const mi_block_t* block) {
 #endif
 
 // only maintain stats for smaller objects if requested
-#if (MI_STAT>0)
-static void mi_stat_free(const mi_page_t* page, const mi_block_t* block) {
-  #if (MI_STAT < 2)  
-  MI_UNUSED(block);
-  #endif
-  mi_heap_t* const heap = mi_heap_get_default();
-  const size_t bsize = mi_page_usable_block_size(page);
-  #if (MI_STAT>1)
-  const size_t usize = mi_page_usable_size_of(page, block);
-  mi_heap_stat_decrease(heap, malloc, usize);
-  #endif  
-  if (bsize <= MI_MEDIUM_OBJ_SIZE_MAX) {
-    mi_heap_stat_decrease(heap, normal, bsize);
-    #if (MI_STAT > 1)
-    mi_heap_stat_decrease(heap, normal_bins[_mi_bin(bsize)], 1);
-    #endif
-  }
-  else if (bsize <= MI_LARGE_OBJ_SIZE_MAX) {
-    mi_heap_stat_decrease(heap, large, bsize);
+static void mi_stat_free(const mi_page_t* page, const mi_block_t* block, bool is_local) {
+  const int prqa_stat_value = tls_prqa_stat;
+  if (prqa_stat_value) {
+    const int base_value = _mi_prqa_stat_base_value(prqa_stat_value);
+    if (prqa_stat_value > 1) {
+      mi_heap_t* const heap = mi_heap_get_default();
+      const size_t usize = mi_page_usable_size_of(page, block);
+      if (base_value > 1) {
+        mi_heap_stat_decrease(heap, malloc, usize);
+      }
+
+      if (is_local && prqa_stat_value >= 10) {
+        mi_heap_stat_do_decrease(heap, prqa_malloc, usize);
+      }
+    }
+
+    if (base_value) {
+      const size_t bsize = mi_page_usable_block_size(page);
+      mi_heap_t* const heap = mi_heap_get_default();
+      if (bsize <= MI_MEDIUM_OBJ_SIZE_MAX) {
+        mi_heap_stat_decrease(heap, normal, bsize);
+        if (base_value > 1) {
+          mi_heap_stat_decrease(heap, normal_bins[_mi_bin(bsize)], 1);
+        }
+      }
+      else if (bsize <= MI_LARGE_OBJ_SIZE_MAX) {
+        mi_heap_stat_decrease(heap, large, bsize);
+      }
+      else {
+        mi_heap_stat_decrease(heap, huge, bsize);
+      }
+    }
   }
-  else {
-    mi_heap_stat_decrease(heap, huge, bsize);
-  }  
-}
-#else
-static void mi_stat_free(const mi_page_t* page, const mi_block_t* block) {
-  MI_UNUSED(page); MI_UNUSED(block);
 }
-#endif
 
 #if MI_HUGE_PAGE_ABANDON
 #if (MI_STAT>0)
@@ -508,7 +525,7 @@ mi_block_t* _mi_page_ptr_unalign(const mi_segment_t* segment, const mi_page_t* p
 
 void mi_decl_noinline _mi_free_generic(const mi_segment_t* segment, mi_page_t* page, bool is_local, void* p) mi_attr_noexcept {
   mi_block_t* const block = (mi_page_has_aligned(page) ? _mi_page_ptr_unalign(segment, page, p) : (mi_block_t*)p);
-  mi_stat_free(page, block);    // stat_free may access the padding
+  mi_stat_free(page, block, is_local);    // stat_free may access the padding
   mi_track_free_size(block, mi_page_usable_size_of(page,block));
   _mi_free_block(page, is_local, block);
 }
@@ -571,7 +588,7 @@ void mi_free(void* p) mi_attr_noexcept
       mi_block_t* const block = (mi_block_t*)p;
       if mi_unlikely(mi_check_is_double_free(page, block)) return;
       mi_check_padding(page, block);
-      mi_stat_free(page, block);
+      mi_stat_free(page, block, is_local);
       #if (MI_DEBUG>0) && !MI_TRACK_ENABLED  && !MI_TSAN
       memset(block, MI_DEBUG_FREED, mi_page_block_size(page));
       #endif
diff --git a/src/heap.c b/src/heap.c
index 58520dd..27a34fd 100644
--- a/src/heap.c
+++ b/src/heap.c
@@ -303,17 +303,23 @@ static bool _mi_heap_page_destroy(mi_heap_t* heap, mi_page_queue_t* pq, mi_page_
       mi_heap_stat_decrease(heap, huge, bsize);
     }
   }
-#if (MI_STAT)
-  _mi_page_free_collect(page, false);  // update used count
-  const size_t inuse = page->used;
-  if (bsize <= MI_LARGE_OBJ_SIZE_MAX) {
-    mi_heap_stat_decrease(heap, normal, bsize * inuse);
-#if (MI_STAT>1)
-    mi_heap_stat_decrease(heap, normal_bins[_mi_bin(bsize)], inuse);
-#endif
+
+  const int prqa_stat_value = tls_prqa_stat;
+  if (prqa_stat_value) {
+    _mi_page_free_collect(page, false);  // update used count
+    const size_t inuse = page->used;
+    const int base_value = _mi_prqa_stat_base_value(prqa_stat_value);
+    if (base_value && bsize <= MI_LARGE_OBJ_SIZE_MAX) {
+      mi_heap_stat_decrease(heap, normal, bsize * inuse);
+      if (base_value > 1) {
+        mi_heap_stat_decrease(heap, normal_bins[_mi_bin(bsize)], inuse);
+      }
+    }
+    mi_heap_stat_decrease(heap, malloc, bsize * inuse);  // todo: off for aligned blocks
+    if (prqa_stat_value >= 10 && _mi_thread_id() == heap->thread_id) {
+      mi_heap_stat_do_decrease(heap, prqa_malloc, bsize * inuse);
+    }
   }
-  mi_heap_stat_decrease(heap, malloc, bsize * inuse);  // todo: off for aligned blocks...
-#endif
 
   /// pretend it is all free now
   mi_assert_internal(mi_page_thread_free(page) == NULL);
diff --git a/src/init.c b/src/init.c
index b1db14c..7c1af08 100644
--- a/src/init.c
+++ b/src/init.c
@@ -82,7 +82,7 @@ const mi_page_t _mi_page_empty = {
   MI_STAT_COUNT_NULL(), MI_STAT_COUNT_NULL(), \
   MI_STAT_COUNT_NULL(), MI_STAT_COUNT_NULL(), \
   MI_STAT_COUNT_NULL(), MI_STAT_COUNT_NULL(), \
-  MI_STAT_COUNT_NULL(), \
+  MI_STAT_COUNT_NULL(), MI_STAT_COUNT_NULL(), \
   { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, \
   { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 } \
   MI_STAT_COUNT_END_NULL()
diff --git a/src/stats.c b/src/stats.c
index 300956c..b6e679f 100644
--- a/src/stats.c
+++ b/src/stats.c
@@ -20,6 +20,35 @@ terms of the MIT license. A copy of the license can be found in the file
   Statistics operations
 ----------------------------------------------------------- */
 
+mi_decl_thread int tls_prqa_stat = MI_STAT;
+
+mi_decl_nodiscard mi_decl_export mi_prqa_stat_t mi_get_prqa_malloc_stat() mi_attr_noexcept {
+  mi_heap_t* heap = mi_prim_get_default_heap();
+  mi_assert(mi_heap_is_initialized(heap));
+  mi_stat_count_t* mc = &heap->tld->stats.prqa_malloc;
+  mi_assert(mc->current >= 0);
+  mi_prqa_stat_t stat = { _mi_thread_id(), mc->current, mc->peak };
+  return stat;
+}
+
+mi_decl_export void mi_reset_prqa_malloc_stat() mi_attr_noexcept {
+  mi_heap_t* heap = mi_prim_get_default_heap();
+  mi_assert(mi_heap_is_initialized(heap));
+  mi_stat_count_t* mc = &heap->tld->stats.prqa_malloc;
+  mc->current = 0;
+  mc->peak = 0;
+}
+
+mi_decl_export void mi_track_prqa_malloc_stat(bool enable) mi_attr_noexcept {
+  const int prqa_stat_value = tls_prqa_stat;
+  if (enable && prqa_stat_value < 10) {
+   tls_prqa_stat = prqa_stat_value + 10;
+  }
+  else if (!enable && prqa_stat_value >= 10) {
+   tls_prqa_stat = prqa_stat_value - 10;
+  }
+}
+
 static bool mi_is_in_main(void* stat) {
   return ((uint8_t*)stat >= (uint8_t*)&_mi_stats_main
          && (uint8_t*)stat < ((uint8_t*)&_mi_stats_main + sizeof(mi_stats_t)));
@@ -133,12 +162,8 @@ static void mi_stats_add(mi_stats_t* stats, const mi_stats_t* src) {
   Display statistics
 ----------------------------------------------------------- */
 
-// unit > 0 : size in binary bytes
-// unit == 0: count as decimal
-// unit < 0 : count in binary
-static void mi_printf_amount(int64_t n, int64_t unit, mi_output_fun* out, void* arg, const char* fmt) {
-  char buf[32]; buf[0] = 0;
-  int  len = 32;
+static void mi_printf_amount_to_char_array(int64_t n, int64_t unit, char* buf, int len, void* arg, const char* fmt) {
+  buf[0] = 0;
   const char* suffix = (unit <= 0 ? " " : "B");
   const int64_t base = (unit == 0 ? 1000 : 1024);
   if (unit>0) n *= unit;
@@ -161,14 +186,25 @@ static void mi_printf_amount(int64_t n, int64_t unit, mi_output_fun* out, void*
     snprintf(unitdesc, 8, "%s%s%s", magnitude, (base==1024 ? "i" : ""), suffix);
     snprintf(buf, len, "%ld.%ld %-3s", whole, (frac1 < 0 ? -frac1 : frac1), unitdesc);
   }
-  _mi_fprintf(out, arg, (fmt==NULL ? "%12s" : fmt), buf);
 }
 
+// unit > 0 : size in binary bytes
+// unit == 0: count as decimal
+// unit < 0 : count in binary
+static void mi_printf_amount(int64_t n, int64_t unit, mi_output_fun* out, void* arg, const char* fmt) {
+  char buf[32];
+  mi_printf_amount_to_char_array(n, unit, buf, 32, arg, fmt);
+  _mi_fprintf(out, arg, (fmt==NULL ? "%12s" : fmt), buf);
+}
 
 static void mi_print_amount(int64_t n, int64_t unit, mi_output_fun* out, void* arg) {
   mi_printf_amount(n,unit,out,arg,NULL);
 }
 
+mi_decl_export void mi_pretty_print_bytes(int64_t n, char* out, int len) mi_attr_noexcept {
+  mi_printf_amount_to_char_array(n, 1, out, len, NULL, NULL);
+}
+
 static void mi_print_count(int64_t n, int64_t unit, mi_output_fun* out, void* arg) {
   if (unit==1) _mi_fprintf(out, arg, "%12s"," ");
           else mi_print_amount(n,0,out,arg);
