diff --git a/include/mimalloc-stats.h b/include/mimalloc-stats.h
index 631f43bb..818cffd2 100644
--- a/include/mimalloc-stats.h
+++ b/include/mimalloc-stats.h
@@ -11,7 +11,8 @@ terms of the MIT license. A copy of the license can be found in the file
 #include <mimalloc.h>
 #include <stdint.h>
 
-#define MI_STAT_VERSION   2   // increased on every backward incompatible change
+#define MI_STAT_VERSION   3   // increased on every backward incompatible change
+#define MIMALLOC_PRQA_STATS
 
 // count allocation over time
 typedef struct mi_stat_count_s {
@@ -37,6 +38,7 @@ typedef struct mi_stat_counter_s {
   MI_STAT_COUNT(malloc_normal)              /* allocated bytes <= MI_LARGE_OBJ_SIZE_MAX */ \
   MI_STAT_COUNT(malloc_huge)                /* allocated bytes in huge pages */ \
   MI_STAT_COUNT(malloc_requested)           /* malloc requested bytes */ \
+  MI_STAT_COUNT(prqa_malloc_requested)      /* malloc requested bytes */ \
   \
   MI_STAT_COUNTER(mmap_calls) \
   MI_STAT_COUNTER(commit_calls) \
@@ -110,6 +112,12 @@ mi_decl_export void    mi_stats_get( size_t stats_size, mi_stats_t* stats ) mi_a
 mi_decl_export char*   mi_stats_get_json( size_t buf_size, char* buf ) mi_attr_noexcept;    // use mi_free to free the result if the input buf == NULL
 mi_decl_export size_t  mi_stats_get_bin_size(size_t bin) mi_attr_noexcept;
 
+mi_decl_export void    mi_pretty_print_bytes(int64_t n, char* out, int len) mi_attr_noexcept;
+
+mi_decl_nodiscard mi_decl_export mi_stat_count_t mi_get_prqa_malloc_stat(void) mi_attr_noexcept;
+mi_decl_export void              mi_reset_prqa_malloc_stat(void) mi_attr_noexcept;
+mi_decl_export void              mi_track_prqa_malloc_stat(bool enable) mi_attr_noexcept;
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/include/mimalloc/internal.h b/include/mimalloc/internal.h
index 62387dc3..308e82ac 100644
--- a/include/mimalloc/internal.h
+++ b/include/mimalloc/internal.h
@@ -369,6 +369,15 @@ void __mi_stat_counter_increase_mt(mi_stat_counter_t* stat, size_t amount);
 #define mi_heap_stat_decrease(heap,stat,amount)                 mi_tld_stat_decrease( heap->tld, stat, amount)
 #define mi_heap_stat_adjust_decrease(heap,stat,amount)          mi_tld_stat_adjust_decrease( heap->tld, stat, amount)
 
+// Applicable to release and debug builds
+extern mi_decl_thread bool tls_prqa_stat;
+
+#define mi_prqa_stat_increase(stat, amount)             __mi_stat_increase(&(stat), amount)
+#define mi_prqa_stat_decrease(stat, amount)             __mi_stat_decrease(&(stat), amount)
+
+#define mi_heap_prqa_stat_increase(heap, stat, amount)  mi_prqa_stat_increase((heap)->tld->stats.stat, amount)
+#define mi_heap_prqa_stat_decrease(heap, stat, amount)  mi_prqa_stat_decrease((heap)->tld->stats.stat, amount)
+
 /* -----------------------------------------------------------
   Options (exposed for the debugger)
 ----------------------------------------------------------- */
diff --git a/src/alloc.c b/src/alloc.c
index 3e912726..eb578aa9 100644
--- a/src/alloc.c
+++ b/src/alloc.c
@@ -94,7 +94,17 @@ extern inline void* _mi_page_malloc_zero(mi_heap_t* heap, mi_page_t* page, size_
     mi_heap_stat_increase(heap, malloc_bins[bin], 1);
     mi_heap_stat_increase(heap, malloc_requested, size - MI_PADDING_SIZE);
     #endif
+    if (tls_prqa_stat) {
+      mi_heap_prqa_stat_increase(heap, prqa_malloc_requested, size - MI_PADDING_SIZE);
+    }
   }
+  #else
+    if (tls_prqa_stat) {
+      const size_t bsize = mi_page_usable_block_size(page);
+      if (bsize <= MI_LARGE_MAX_OBJ_SIZE) {
+        mi_heap_prqa_stat_increase(heap, prqa_malloc_requested, size - MI_PADDING_SIZE);
+      }
+    }
   #endif
 
   #if MI_PADDING // && !MI_TRACK_ENABLED
@@ -664,6 +674,10 @@ mi_decl_restrict void* _mi_heap_malloc_guarded(mi_heap_t* heap, size_t size, boo
     mi_heap_stat_adjust_decrease(heap, malloc_requested, req_size);
     mi_heap_stat_increase(heap, malloc_requested, size);
     #endif
+    if (tls_prqa_stat) {
+      mi_heap_prqa_stat_decrease(heap, prqa_malloc_requested, req_size);
+      mi_heap_prqa_stat_increase(heap, prqa_malloc_requested, size);
+    }
     mi_heap_stat_counter_increase(heap, malloc_guarded_count, 1);
   }
   #if MI_DEBUG>3
diff --git a/src/free.c b/src/free.c
index 40e81380..7197e297 100644
--- a/src/free.c
+++ b/src/free.c
@@ -530,9 +530,9 @@ static void mi_check_padding(const mi_page_t* page, const mi_block_t* block) {
 #endif
 
 // only maintain stats for smaller objects if requested
-#if (MI_STAT>0)
 static void mi_stat_free(const mi_page_t* page, const mi_block_t* block) {
   MI_UNUSED(block);
+#if (MI_STAT>0)
   mi_heap_t* const heap = mi_heap_get_default();
   const size_t bsize = mi_page_usable_block_size(page);
   // #if (MI_STAT>1)
@@ -549,12 +549,22 @@ static void mi_stat_free(const mi_page_t* page, const mi_block_t* block) {
     const size_t bpsize = mi_page_block_size(page);  // match stat in page.c:mi_huge_page_alloc
     mi_heap_stat_decrease(heap, malloc_huge, bpsize);
   }
-}
+
+  if (tls_prqa_stat) {
+    if (_mi_thread_id() == heap->tld->thread_id) {
+      mi_heap_prqa_stat_decrease(heap, prqa_malloc_requested, bsize);
+    }
+  }
 #else
-void mi_stat_free(const mi_page_t* page, const mi_block_t* block) {
-  MI_UNUSED(page); MI_UNUSED(block);
-}
+  if (tls_prqa_stat) {
+    mi_heap_t* const heap = mi_heap_get_default();
+    if (_mi_thread_id() == heap->tld->thread_id) {
+      const size_t bsize = mi_page_usable_block_size(page);
+      mi_heap_prqa_stat_decrease(heap, prqa_malloc_requested, bsize);
+    }
+  }
 #endif
+}
 
 
 // Remove guard page when building with MI_GUARDED
diff --git a/src/init.c b/src/init.c
index 73847a4b..b02196d5 100644
--- a/src/init.c
+++ b/src/init.c
@@ -71,7 +71,7 @@ const mi_page_t _mi_page_empty = {
 #define MI_STATS_NULL  \
   MI_STAT_COUNT_NULL(), MI_STAT_COUNT_NULL(), MI_STAT_COUNT_NULL(), MI_STAT_COUNT_NULL(), \
   MI_STAT_COUNT_NULL(), MI_STAT_COUNT_NULL(), MI_STAT_COUNT_NULL(), MI_STAT_COUNT_NULL(), \
-  MI_STAT_COUNT_NULL(), MI_STAT_COUNT_NULL(), MI_STAT_COUNT_NULL(), \
+  MI_STAT_COUNT_NULL(), MI_STAT_COUNT_NULL(), MI_STAT_COUNT_NULL(), MI_STAT_COUNT_NULL(), \
   { 0 }, { 0 }, { 0 }, { 0 }, \
   { 0 }, { 0 }, { 0 }, { 0 }, \
   \
diff --git a/src/stats.c b/src/stats.c
index 4eba519a..1dbcafcb 100644
--- a/src/stats.c
+++ b/src/stats.c
@@ -19,6 +19,30 @@ terms of the MIT license. A copy of the license can be found in the file
   Statistics operations
 ----------------------------------------------------------- */
 
+mi_decl_thread bool tls_prqa_stat = false;
+
+mi_decl_nodiscard mi_decl_export mi_stat_count_t mi_get_prqa_malloc_stat(void) mi_attr_noexcept {
+  if (tls_prqa_stat) {
+    mi_heap_t* heap = mi_prim_get_default_heap();
+    mi_assert(mi_heap_is_initialized(heap));
+    return heap->tld->stats.prqa_malloc_requested;
+  }
+  mi_stat_count_t zero = {0,0,0};
+  return zero;
+}
+
+mi_decl_export void mi_reset_prqa_malloc_stat(void) mi_attr_noexcept {
+  if (tls_prqa_stat) {
+    mi_heap_t* heap = mi_prim_get_default_heap();
+    mi_assert(mi_heap_is_initialized(heap));
+    memset(&heap->tld->stats.prqa_malloc_requested, 0, sizeof(mi_stat_count_t));
+  }
+}
+
+mi_decl_export void mi_track_prqa_malloc_stat(bool enable) mi_attr_noexcept {
+  tls_prqa_stat = enable;
+}
+
 static void mi_stat_update_mt(mi_stat_count_t* stat, int64_t amount) {
   if (amount == 0) return;
   // add atomically
@@ -134,12 +158,8 @@ static void mi_stats_add(mi_stats_t* stats, const mi_stats_t* src) {
   Display statistics
 ----------------------------------------------------------- */
 
-// unit > 0 : size in binary bytes
-// unit == 0: count as decimal
-// unit < 0 : count in binary
-static void mi_printf_amount(int64_t n, int64_t unit, mi_output_fun* out, void* arg, const char* fmt) {
-  char buf[32]; _mi_memzero_var(buf);
-  int  len = 32;
+static void mi_printf_amount_to_char_array(int64_t n, int64_t unit, char* buf, int len) {
+  memset(buf, 0, len);
   const char* suffix = (unit <= 0 ? " " : "B");
   const int64_t base = (unit == 0 ? 1000 : 1024);
   if (unit>0) n *= unit;
@@ -162,9 +182,16 @@ static void mi_printf_amount(int64_t n, int64_t unit, mi_output_fun* out, void*
     _mi_snprintf(unitdesc, 8, "%s%s%s", magnitude, (base==1024 ? "i" : ""), suffix);
     _mi_snprintf(buf, len, "%ld.%ld %-3s", whole, (frac1 < 0 ? -frac1 : frac1), unitdesc);
   }
-  _mi_fprintf(out, arg, (fmt==NULL ? "%12s" : fmt), buf);
 }
 
+// unit > 0 : size in binary bytes
+// unit == 0: count as decimal
+// unit < 0 : count in binary
+static void mi_printf_amount(int64_t n, int64_t unit, mi_output_fun* out, void* arg, const char* fmt) {
+  char buf[32];
+  mi_printf_amount_to_char_array(n, unit, buf, 32);
+  _mi_fprintf(out, arg, (fmt==NULL ? "%12s" : fmt), buf);
+}
 
 static void mi_print_amount(int64_t n, int64_t unit, mi_output_fun* out, void* arg) {
   mi_printf_amount(n,unit,out,arg,NULL);
@@ -175,6 +202,10 @@ static void mi_print_count(int64_t n, int64_t unit, mi_output_fun* out, void* ar
           else mi_print_amount(n,0,out,arg);
 }
 
+mi_decl_export void mi_pretty_print_bytes(int64_t n, char* out, int len) mi_attr_noexcept {
+  mi_printf_amount_to_char_array(n, 1, out, len);
+}
+
 static void mi_stat_print_ex(const mi_stat_count_t* stat, const char* msg, int64_t unit, mi_output_fun* out, void* arg, const char* notok ) {
   _mi_fprintf(out, arg,"%10s:", msg);
   if (unit != 0) {
@@ -410,7 +441,9 @@ void _mi_stats_merge_from(mi_stats_t* to, mi_stats_t* from) {
   mi_assert_internal(to != NULL && from != NULL);
   if (to != from) {
     mi_stats_add(to, from);
+    mi_stat_count_t temp = from->prqa_malloc_requested;
     _mi_memzero(from, sizeof(mi_stats_t));
+    from->prqa_malloc_requested = temp;
   }
 }
 
