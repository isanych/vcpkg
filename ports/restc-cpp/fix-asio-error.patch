diff --git a/include/restc-cpp/helper.h b/include/restc-cpp/helper.h
index d2a94ec..1c554d1 100644
--- a/include/restc-cpp/helper.h
+++ b/include/restc-cpp/helper.h
@@ -15,6 +15,32 @@
 	#define strncasecmp _strnicmp
 #endif
 
+#if BOOST_VERSION >= 108700
+namespace boost {
+  namespace asio {
+    using io_service = boost::asio::io_context;
+    using const_buffers_1 = boost::asio::const_buffer;
+    using mutable_buffers_1 = boost::asio::mutable_buffer;
+    using io_context_work = boost::asio::executor_work_guard<boost::asio::io_context::executor_type>;
+    /// Cast a non-modifiable buffer to a specified pointer to POD type.
+    template <typename PointerToPodType>
+    inline PointerToPodType buffer_cast(const mutable_buffer& b) noexcept
+    {
+        return static_cast<PointerToPodType>(b.data());
+    }
+
+    /// Cast a non-modifiable buffer to a specified pointer to POD type.
+    template <typename PointerToPodType>
+    inline PointerToPodType buffer_cast(const const_buffer& b) noexcept
+    {
+        return static_cast<PointerToPodType>(b.data());
+    }
+  }
+}
+#else
+    using io_context_work = boost::asio::io_service::work;
+#endif
+
 namespace restc_cpp {
 
 // recommended in Meyers, Effective STL when internationalization and embedded
diff --git a/src/ChunkedReaderImpl.cpp b/src/ChunkedReaderImpl.cpp
index 259e5ef..40ed7e9 100644
--- a/src/ChunkedReaderImpl.cpp
+++ b/src/ChunkedReaderImpl.cpp
@@ -57,13 +57,13 @@ public:
     }
 
     void Log(const boost::asio::const_buffers_1 buffers, const char *tag) {
-        const auto buf_len = boost::asio::buffer_size(*buffers.begin());
+        const auto buf_len = boost::asio::buffer_size(buffers);
 
         // At the time of the implementation, there are never multiple buffers.
         RESTC_CPP_LOG_TRACE_(tag << ' ' << "# " << buf_len
             << " bytes: "
             << ToPrintable({
-                boost::asio::buffer_cast<const char *>(*buffers.begin()),
+                boost::asio::buffer_cast<const char *>(buffers.data()),
                            buf_len}));
     }
 
diff --git a/src/ConnectionPoolImpl.cpp b/src/ConnectionPoolImpl.cpp
index 9cf8cef..cc98c21 100644
--- a/src/ConnectionPoolImpl.cpp
+++ b/src/ConnectionPoolImpl.cpp
@@ -187,7 +187,7 @@ public:
 
     std::future<std::size_t> GetIdleConnections() const override {
         auto my_promise = make_shared<promise<size_t>>() ;
-        GetCtx().dispatch([my_promise, this]() {
+        boost::asio::dispatch(GetCtx(), [my_promise, this]() {
             my_promise->set_value(idle_.size());
         });
         return my_promise->get_future();
@@ -196,7 +196,7 @@ public:
     void Close() override {
         if (!closed_) {
             closed_ = true;
-            GetCtx().dispatch([this]{
+            boost::asio::dispatch(GetCtx(), [this]{
                 cache_cleanup_timer_.cancel();
                 idle_.clear();
             });
@@ -209,7 +209,7 @@ public:
 
 private:
     void ScheduleNextCacheCleanup() {
-        GetCtx().dispatch([this]{
+        boost::asio::dispatch(GetCtx(), [this]{
             cache_cleanup_timer_.expires_from_now(
                 boost::posix_time::seconds(properties_->cacheCleanupIntervalSeconds));
             cache_cleanup_timer_.async_wait(std::bind(&ConnectionPoolImpl::OnCacheCleanup,
@@ -254,7 +254,7 @@ private:
     }
 
     void OnRelease(const Entry::ptr_t& entry) {
-        GetCtx().dispatch([this, entry]{
+        boost::asio::dispatch(GetCtx(), [this, entry]{
             in_use_.erase(entry->GetKey());
             if (closed_ || !entry->GetConnection()->GetSocket().IsOpen()) {
                 RESTC_CPP_LOG_TRACE_("Discarding " << *entry << " after use");
@@ -277,7 +277,7 @@ private:
         promise<bool> pr;
         auto result = pr.get_future();
 
-        GetCtx().dispatch([this, &ep, connectionType, &pr]() {
+        boost::asio::dispatch(GetCtx(), [this, &ep, connectionType, &pr]() {
             {
                 const auto key = Key{ep, connectionType};
                 const size_t ep_cnt = idle_.count(key) + in_use_.count(key);
@@ -336,7 +336,7 @@ private:
         promise<Connection::ptr_t> pr;
         auto result = pr.get_future();
 
-        GetCtx().dispatch([this, &ep, connectionType, &pr]{
+        boost::asio::dispatch(GetCtx(), [this, &ep, connectionType, &pr]{
             const auto key = Key{ep, connectionType};
             auto it = idle_.find(key);
             if (it != idle_.end()) {
@@ -377,7 +377,7 @@ private:
         promise<Connection::ptr_t> pr;
         auto result = pr.get_future();
 
-        GetCtx().dispatch([this, entry=move(entry), &pr]{
+        boost::asio::dispatch(GetCtx(), [this, entry=move(entry), &pr]{
             in_use_.insert({entry->GetKey(), entry});
             pr.set_value(make_unique<ConnectionWrapper>(entry, on_release_));
         });
diff --git a/src/RequestImpl.cpp b/src/RequestImpl.cpp
index f718119..c5230af 100644
--- a/src/RequestImpl.cpp
+++ b/src/RequestImpl.cpp
@@ -265,7 +265,7 @@ private:
         return request_buffer.str();
     }
 
-    boost::asio::ip::tcp::resolver::query GetRequestEndpoint() {
+    std::pair<std::string, std::string> GetRequestEndpoint() {
         if (properties_->proxy.type == Request::Proxy::Type::HTTP) {
             Url proxy {properties_->proxy.address.c_str()};
 
@@ -303,17 +303,15 @@ private:
 
         boost::asio::ip::tcp::resolver resolver(owner_.GetIoService());
         // Resolve the hostname
-        const auto query = GetRequestEndpoint();
+        const auto& [host, port] = GetRequestEndpoint();
 
         RESTC_CPP_LOG_TRACE_("Resolving " << query.host_name() << ":"
             << query.service_name());
 
-        auto address_it = resolver.async_resolve(query,
+        auto results = resolver.async_resolve(host, port,
                                                  ctx.GetYield());
-        const decltype(address_it) addr_end;
-
-        for(; address_it != addr_end; ++address_it) {
-            const auto endpoint = address_it->endpoint();
+        for(auto address_it : results) {
+            const auto endpoint = address_it.endpoint();
 
             RESTC_CPP_LOG_TRACE_("Trying endpoint " << endpoint);
 
@@ -331,7 +329,7 @@ private:
 
                 try {
                     connection->GetSocket().AsyncConnect(
-                        endpoint, address_it->host_name(), ctx.GetYield());
+                        endpoint, address_it.host_name(), ctx.GetYield());
                 } catch(const exception& ex) {
                     RESTC_CPP_LOG_WARN_("Connect to "
                         << endpoint
diff --git a/src/RestClientImpl.cpp b/src/RestClientImpl.cpp
index 8af82fd..dbec636 100644
--- a/src/RestClientImpl.cpp
+++ b/src/RestClientImpl.cpp
@@ -189,7 +189,7 @@ public:
 
         thread_ = make_unique<thread>([&]() {
             lock_guard<decltype(done_mutex_)> lock(done_mutex_);
-            work_ = make_unique<boost::asio::io_service::work>(*io_service_);
+            work_ = make_unique<boost::asio::io_context_work>(io_service_->get_executor());
             wait.set_value();
             RESTC_CPP_LOG_DEBUG_("Worker is starting.");
             io_service_->run();
@@ -208,7 +208,7 @@ public:
     void CloseWhenReady(bool wait) override {
         ClearWork();
         if (!io_service_->stopped()) {
-            io_service_->dispatch([this](){
+            boost::asio::dispatch(*io_service_, [this](){
                 if (current_tasks_ == 0) {
                     OnNoMoreWork();
                 }
@@ -229,7 +229,7 @@ public:
         if (!io_service_->stopped()) {
             auto promise = make_shared<std::promise<void>>();
 
-            io_service_->dispatch([this, promise]() {
+            boost::asio::dispatch(*io_service_, [this, promise]() {
                 if (work_) {
                     work_.reset();
                 }
@@ -322,7 +322,7 @@ private:
     Request::Properties::ptr_t default_connection_properties_ = make_shared<Request::Properties>();
     boost::asio::io_service *io_service_ = nullptr;
     ConnectionPool::ptr_t pool_;
-    unique_ptr<boost::asio::io_service::work> work_;
+    unique_ptr<boost::asio::io_context_work> work_;
     size_t current_tasks_ = 0;
     bool closed_ = false;
     unique_ptr<thread> thread_;
